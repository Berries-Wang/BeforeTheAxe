# Maven 坐标和依赖
## 坐标详解
&nbsp;&nbs;Maven坐标为各种构件引入了秩序，任何一个构件都必须明确定义自己的坐标，而一组Maven坐标是通过一些元素定义的，他们是 groupId、artifactId、version、packaging、classifier。示例：
```xml
   <groupId>org.sonatype.nexus</groupId>
   <artifactId>nexus-indexer</artifactId>
   <version>2.0.0</version>
   <packaging>jar<packaging>
```

  - 这是nexus-indexer的坐标定义，nexus-indexer是一个对Maven仓库编撰索引并提供搜索功能的类库，他是Nexus项目的一个子模块。在上述代码片段中，其中坐标分别为： groupId:org.sonatype.nexus , artifactId: nexus-indexer , version: 2.0.0 , packaging: jar , 没有classifier。如下详细讲解该坐标:

    1. groupId: 定义当前Maven项目隶属的实际项目。
        + 首先，Maven项目和实际项目不一定是一对一的关系。比如SpringFramework这一实际的项目，其对应的Maven项目会有很多，例如 spring-core,spring-context等。这是由于Maven中模块的概念，因此，一个实际项目往往会被划分为很多模块。
        + 其次，groupId不应该对应项目隶属的组织或者公司。原因很简单，一个组织或者公司下会有很多实际项目。如果groupId只定义到组织级别，那么artifactId只能定义Maven项目(模块）,那么实际项目这个层将难以对应。
        + 最后，groupId的命名格式： groupId的表示方式和Java包命名的表示方式类似，通常与域名反向一一对应。上例中： groupId就是org.sonatype.nexus。org.sonatype表示Sonatype公司建立的一个非盈利性项目,nexus表示Nexus这一个实际项目。该groupId与域名nexus.sonatype.org对应。

    2. artifactId: 该元素定义实际项目中的一个Maven项目(模块),推荐的做法是使用实际项目名称作为artifactId的前缀，比如上例的artifactId是nexus-indexer.使用了实际项目名称作为artifactId的前缀，这样的好处是方便寻找实际构件。在默认的情况下，Maven生成的构件，其文件名称会以artifactId作为开头，如 nexus-indexer-2.0.0.jar,使用实际项目名称作为前缀之后，就能方便从一个lib文件夹中找到某个项目的一组构件。
    3. version: 该元素定义Maven项目当前所处的版本，如上例中nexus-indexer的版本是2.0.0，需要注意的是，Maven定义了一套完整的版本规范，以及快照(SNAPSHOT)的概念。
    4. packaging: 该元素定义Maven项目的打包方式。
        + 首先，打包方式通常与所生成构件的拓展名对应，比如上例中的packaging为jar，最终的文件名为nexus-indexer-2.0.0.jar;而使用war打包方式的Maven项目，最终生成的构件会有一个.war文件。但这不是绝对的。
        + 其次，打包方式会影响到构建的生命周期，例如jar打包和war打包会使用不同的命令。
        + 最后，Maven默认的packaging为jar
   5. classfier: 该元素用来帮助定义构建输出的一些附属构件。附属构件和主构建对应，例如上面的主构件是nexus-indexer-2.0.0.jar,该项目还可能会通过一些插件生成如nexus-indexer-2.0.0-javadoc.jar,nexus-indexer-2.0.0.source.jar这样一些附属构件，其分别包含java文档和源代码。这时候，javadoc和source就是这两个附属构件的classfier。这样，附属构件也拥有了自己唯一的坐标。

在上述5个元素中，groupId，artifactId，version是必须定义的，packaging是可选的(默认为jar),而classfier不能是直接定义的。


