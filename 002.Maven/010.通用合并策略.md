# Maven通用合并策略--Maven的继承
## 概念
&nbsp;&nbsp;在Maven继承中,存在一个应用场景： 对于plugin ， dependency , execution等标签来说(这些标签都是有"唯一标识符"机制，例如对于plugin标签来说，groupId:artifactId是其唯一标识符；对于dependency标签来说,groupId:artifactId是其唯一标识符;对于execution标签来说，id就是其唯一标识符)，在祖先POM和后代的POM中可以定义相同(这里的相同是指“唯一标识符”相同)的标签内容，那么，在最终获得的有效POM中，关于这些标签的内容是什么呢?

## 通用合并策略
&nbsp;&nbsp;基于如上的背景，在这里就需要介绍POM中的通用合并策略。通用合并策略有如下几点概念:
1. 通用合并策略适用于具有“唯一标识”机制的标签，例如plugin,dependency,execution等
2. 在祖先POM中定义了一个标签内容，在后代POM中也定义了一个相同的标签内容(指的是唯一标识符一致)，那么在最终获得的POM中，关于该标签内容的获取步骤如下:
   - 简单属性： 若后代POM中定义了该值，那么最终值就是该值；若祖先POM中定义了该值，那么最终值就是该值；若都没有定义，则最终值为空。
   - List属性： 如果List中的元素是简单属性，那么后代POM中定义的List和祖先POM中定义的List进行去重合并；如果List中元素是支持唯一标识符的复杂属性，那么后代POM中定义的List属性和祖先POM中定义的List进行合并，在合并的过程中，递归调用通用合并策略。
   - Map属性：在后代POM中定义的Map和祖先POM中定义的Map进行合并，如果合并的时候碰到同一个Key，那么后代POM中定义的value值比祖先POM中定义的value值具有更高的优先级。

### 总结
&nbsp;&nbsp;在通用合并策略中(或者称之为Maven的继承)，子POM定义的属性比祖先POM中定义的属性具有更高的优先级。（但是需要注意的是： 对比是基于如上的“**唯一标识符**”机制）